{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Wonder Works Programming Guide This is the comprehensive guide that all programmers under the Wonder Works company must follow. From our current libraries to best practices - this guide should serve you well. If you have any questions please feel free to ask your fellow coworkers and/or ask a Lead Developer for guidance. Lets start with Resources to understand the basics of the guide.","title":"Home"},{"location":"#wonder-works-programming-guide","text":"This is the comprehensive guide that all programmers under the Wonder Works company must follow. From our current libraries to best practices - this guide should serve you well. If you have any questions please feel free to ask your fellow coworkers and/or ask a Lead Developer for guidance. Lets start with Resources to understand the basics of the guide.","title":"Wonder Works Programming Guide"},{"location":"knit/","text":"Knit Framework Knit Framework Why Knit Knit luckily is not a strict structured framework and more of a modular library. Knit is designed in a way that lets the developers decide their own structure while still accessing all of the same functionality and benefits it has to offer. Knit can easily be added to pre-existing code or start the creation of an application that is future-proof when it comes to new updates and features. How Knit Works Name Description Service Server-Side Code that has a specific purpose. Initialized during Knit.Start() Controllers Client-Side Code that has a specific purpose. Initialized during Knit.Start() Modules Separate ModuleScripts that are used as either classes, information storage, libraries, or multi-usage functions Check out this getting started documentation to learn more but at startup all Knit needs is to run it's Start() function once on both the server and client. local ReplicatedStorage = game:GetService(\"ReplicatedStorage\") local Knit = require(ReplicatedStorage.Knit) Knit.Start():Catch(warn) -- Start() returns a Promise that catches any error with the initial startup that then uses warn to output the error. While this is how you start Knit, it will need more code before it is close to production-ready. Services Services are meant to have a specific purpose and only relate to that purpose. DataService would have all battle-related functionality. CurrencyService would have all currency-related functionality. Services only need to require Knit, declare the service, and initialize the service. KnitInit() method is fired during the startup of Knit.Start() which means KnitInit cannot yield or it will prevent other code from running. After all KnitInit methods are ran, KnitStart() methods are ran on their own which means they can yield if needed. local ReplicatedStorage = game:GetService(\"ReplicatedStorage\") local Knit = require(ReplicatedStorage.Knit) local CurrencyService = Knit.CreateService { Name = \"CurrencyService\", Client = {}, } function CurrencyService:KnitStart() -- declare variables, wait for children, etc. end function CurrencyService:KnitInit() -- no yielding end If I wanted to have the client communicate with the service and get information back from it I could set up a method that is exposed to the client. -- on the server from the Service ModuleScript function CurrencyService.Client:GetInformation() return \"some information\" end -- on the client from a LocalScript local CurrencyService = Knit.GetService(\"CurrencyService\") local information = CurrencyService:GetInformation() Controllers Controllers follow the exact same structure as Services. local ReplicatedStorage = game:GetService(\"ReplicatedStorage\") local Knit = require(ReplicatedStorage.Knit) local MovementController = Knit.CreateController { Name = \"MovementController\"; } function MovementController:KnitStart() -- declare variables, wait for children, etc. end function MovementController:KnitInit() -- no yielding end Util Knit comes with a lot of neat libraries at your disposal. Maid Maid is a your most useful tool for tracking and disposing of potential memory leaks. It will disconnect events, destroy objects, you name it! Read up on it more here . It is really easy to use and take advantage of so make sure to do so. Promises Promises allows for a safe way to catch values that may exist in the future but might not exist now. Not only does this safeguard you and your code but it prevents yielding until a value may exist. Useful for managing asynchronous code. local HttpService = game:GetService(\"HttpService\") local function httpGet(url) return Promise.new(function(resolve, reject) local success, result = pcall(HttpService.GetAsync, HttpService, url) if success then resolve(result) else reject(result) end end) end httpGet(\"https://www.google.com\"):Then(function(result) -- if successful then end):Catch(function(error) -- rejected, lets handle rejection end) print(\"The rest of the script is not waiting on this result! Wooo\") Signal and RemoteSignal and RemoteProperty Lets group these together for simplicity. Signal and RemoteSignal are wrappers for BindableEvents and RemoteEvents respectively. They provide more functionality for developers to take advantage which saves us time in the long run. RemoteProperty are in a way similar to RemoteEvents but instead expose a read-only Value to the client that is updated whenever it is set. The client can :Get() this Value at any point and also setup a .Changed connection to know as soon as the Value object is changed. All three of these should be used instead of BindableEvents. and RemoteEvents. If you're wondering \"what about RemoteFunctions?\" refer back to the Services portion of this page. Signal RemoteSignal RemoteProperty","title":"Knit"},{"location":"knit/#knit-framework","text":"Knit Framework","title":"Knit Framework"},{"location":"knit/#why-knit","text":"Knit luckily is not a strict structured framework and more of a modular library. Knit is designed in a way that lets the developers decide their own structure while still accessing all of the same functionality and benefits it has to offer. Knit can easily be added to pre-existing code or start the creation of an application that is future-proof when it comes to new updates and features.","title":"Why Knit"},{"location":"knit/#how-knit-works","text":"Name Description Service Server-Side Code that has a specific purpose. Initialized during Knit.Start() Controllers Client-Side Code that has a specific purpose. Initialized during Knit.Start() Modules Separate ModuleScripts that are used as either classes, information storage, libraries, or multi-usage functions Check out this getting started documentation to learn more but at startup all Knit needs is to run it's Start() function once on both the server and client. local ReplicatedStorage = game:GetService(\"ReplicatedStorage\") local Knit = require(ReplicatedStorage.Knit) Knit.Start():Catch(warn) -- Start() returns a Promise that catches any error with the initial startup that then uses warn to output the error. While this is how you start Knit, it will need more code before it is close to production-ready.","title":"How Knit Works"},{"location":"knit/#services","text":"Services are meant to have a specific purpose and only relate to that purpose. DataService would have all battle-related functionality. CurrencyService would have all currency-related functionality. Services only need to require Knit, declare the service, and initialize the service. KnitInit() method is fired during the startup of Knit.Start() which means KnitInit cannot yield or it will prevent other code from running. After all KnitInit methods are ran, KnitStart() methods are ran on their own which means they can yield if needed. local ReplicatedStorage = game:GetService(\"ReplicatedStorage\") local Knit = require(ReplicatedStorage.Knit) local CurrencyService = Knit.CreateService { Name = \"CurrencyService\", Client = {}, } function CurrencyService:KnitStart() -- declare variables, wait for children, etc. end function CurrencyService:KnitInit() -- no yielding end If I wanted to have the client communicate with the service and get information back from it I could set up a method that is exposed to the client. -- on the server from the Service ModuleScript function CurrencyService.Client:GetInformation() return \"some information\" end -- on the client from a LocalScript local CurrencyService = Knit.GetService(\"CurrencyService\") local information = CurrencyService:GetInformation()","title":"Services"},{"location":"knit/#controllers","text":"Controllers follow the exact same structure as Services. local ReplicatedStorage = game:GetService(\"ReplicatedStorage\") local Knit = require(ReplicatedStorage.Knit) local MovementController = Knit.CreateController { Name = \"MovementController\"; } function MovementController:KnitStart() -- declare variables, wait for children, etc. end function MovementController:KnitInit() -- no yielding end","title":"Controllers"},{"location":"knit/#util","text":"Knit comes with a lot of neat libraries at your disposal.","title":"Util"},{"location":"knit/#maid","text":"Maid is a your most useful tool for tracking and disposing of potential memory leaks. It will disconnect events, destroy objects, you name it! Read up on it more here . It is really easy to use and take advantage of so make sure to do so.","title":"Maid"},{"location":"knit/#promises","text":"Promises allows for a safe way to catch values that may exist in the future but might not exist now. Not only does this safeguard you and your code but it prevents yielding until a value may exist. Useful for managing asynchronous code. local HttpService = game:GetService(\"HttpService\") local function httpGet(url) return Promise.new(function(resolve, reject) local success, result = pcall(HttpService.GetAsync, HttpService, url) if success then resolve(result) else reject(result) end end) end httpGet(\"https://www.google.com\"):Then(function(result) -- if successful then end):Catch(function(error) -- rejected, lets handle rejection end) print(\"The rest of the script is not waiting on this result! Wooo\")","title":"Promises"},{"location":"knit/#signal-and-remotesignal-and-remoteproperty","text":"Lets group these together for simplicity. Signal and RemoteSignal are wrappers for BindableEvents and RemoteEvents respectively. They provide more functionality for developers to take advantage which saves us time in the long run. RemoteProperty are in a way similar to RemoteEvents but instead expose a read-only Value to the client that is updated whenever it is set. The client can :Get() this Value at any point and also setup a .Changed connection to know as soon as the Value object is changed. All three of these should be used instead of BindableEvents. and RemoteEvents. If you're wondering \"what about RemoteFunctions?\" refer back to the Services portion of this page. Signal RemoteSignal RemoteProperty","title":"Signal and RemoteSignal and RemoteProperty"},{"location":"resources/","text":"Resources Roblox Lua Style Guide The Roblox Lua Style guide is the baseline for best practices. It is a necessity to go through this guide first and then come back to learn more. Roblox Lua Style Guide Framework As of July 2021, Wonder Works Studio is currently using the Knit Framework as our bread and butter for all of our games on the Roblox platform. Knit luckily is not a strict structured framework and more of a modular library. Knit is designed in a way that lets the developers decide their own structure while still accessing all of the same functionality and benefits it has to offer. While we may design our own framework in the future, it would end up very similar in design to the way Knit functions now which is perfect for our current uses. I have dedicated a section to go over some basics of Knit but it is very important to read up on the framework through its actual documentation. Knit Framework DataStore Library As with Knit, we are using another open-sourced project for our datastore systems. Profile Service has a lot of benefits such as session-locking with features like MetaTags and GlobalUpdates when adding new content to the project. We could also create our own DataStore system in the near future but this currently has everything we could possibly need and more at its current capabilities. Profile Service Feel free to make any modifications to adapt on a per-project basis. This could include web-service, MemoryStore, or any additional cloud service features. Roact, Rodux, And Their Integration As with everything in this guide, we are only glancing at the surface here with the introduction of these libraries. You will have to test out using these libraries yourself and really play around with how things operate and function. There are plenty of resources at your disposal and your coworkers will be more than willing to assist you with any questions you may have. Roact Roact is a Roblox Lua UI Library which serves the purpose of handling the creation and usage of the player's user interface. Since Roact was built to be very similar to Facebook's React Library, it has a lot of the same principles and functionality that makes it an industry standard. If you're new to Roact, I would look at this devforum guide to begin the learning process. As you will soon learn, using Roact takes much longer to implement depending on the project. So why do we use it? The perks of Roact become clear as your project takes shape. Roact helps you define what your UI should be doing compared to how it should do it. This means less unknown bugs, more manageable code, and easy reusability. The perks become even more transparent when combined with Rodux. Roact Rodux Similar to how Roact was formed, Rodux is based off it's predecessor Redux with the same purpose in mind; to be the ideal state library. As the word 'state' is defined, we can declare the condition of our application at a specific time and that will never change unless we change it. This means one source of truth - it's state. If a round-based game is in intermission then it's state would be set to intermission. The rest of the game's code would have no way to define it's own 'truth'. Obviously with a medium to large project you may have several states. Is a specific UI window open? What tool is the player holding? What location is the player in? Rodux tackles this by creating 'The Store'. Store has a state, a reducer, and a dispatcher. The state is a simple dictionary to define the data of the store. local state = { location = \"Texas\", inventoryWindowOpen = false, weaponHeld = \"\", } Then the dispatcher handles all of the incoming action objects and sends them to the reducer. The dispatcher can be considered a middle man and a middleware can be setup to catch all actions and modify the action before being sent to the reducer. The reducer takes in an action object and the current state of the store and returns a new state based off of the action. Rodux Roact-Rodux Integration While Roact and Rodux can be used separately for their own specific uses, they can and should be used together. Defining the current state of the user's interface prevents a lot unknown errors and simplifies the long-term development process. Roact-Rodux","title":"Resources"},{"location":"resources/#resources","text":"","title":"Resources"},{"location":"resources/#roblox-lua-style-guide","text":"The Roblox Lua Style guide is the baseline for best practices. It is a necessity to go through this guide first and then come back to learn more. Roblox Lua Style Guide","title":"Roblox Lua Style Guide"},{"location":"resources/#framework","text":"As of July 2021, Wonder Works Studio is currently using the Knit Framework as our bread and butter for all of our games on the Roblox platform. Knit luckily is not a strict structured framework and more of a modular library. Knit is designed in a way that lets the developers decide their own structure while still accessing all of the same functionality and benefits it has to offer. While we may design our own framework in the future, it would end up very similar in design to the way Knit functions now which is perfect for our current uses. I have dedicated a section to go over some basics of Knit but it is very important to read up on the framework through its actual documentation. Knit Framework","title":"Framework"},{"location":"resources/#datastore-library","text":"As with Knit, we are using another open-sourced project for our datastore systems. Profile Service has a lot of benefits such as session-locking with features like MetaTags and GlobalUpdates when adding new content to the project. We could also create our own DataStore system in the near future but this currently has everything we could possibly need and more at its current capabilities. Profile Service Feel free to make any modifications to adapt on a per-project basis. This could include web-service, MemoryStore, or any additional cloud service features.","title":"DataStore Library"},{"location":"resources/#roact-rodux-and-their-integration","text":"As with everything in this guide, we are only glancing at the surface here with the introduction of these libraries. You will have to test out using these libraries yourself and really play around with how things operate and function. There are plenty of resources at your disposal and your coworkers will be more than willing to assist you with any questions you may have.","title":"Roact, Rodux, And Their Integration"},{"location":"resources/#roact","text":"Roact is a Roblox Lua UI Library which serves the purpose of handling the creation and usage of the player's user interface. Since Roact was built to be very similar to Facebook's React Library, it has a lot of the same principles and functionality that makes it an industry standard. If you're new to Roact, I would look at this devforum guide to begin the learning process. As you will soon learn, using Roact takes much longer to implement depending on the project. So why do we use it? The perks of Roact become clear as your project takes shape. Roact helps you define what your UI should be doing compared to how it should do it. This means less unknown bugs, more manageable code, and easy reusability. The perks become even more transparent when combined with Rodux. Roact","title":"Roact"},{"location":"resources/#rodux","text":"Similar to how Roact was formed, Rodux is based off it's predecessor Redux with the same purpose in mind; to be the ideal state library. As the word 'state' is defined, we can declare the condition of our application at a specific time and that will never change unless we change it. This means one source of truth - it's state. If a round-based game is in intermission then it's state would be set to intermission. The rest of the game's code would have no way to define it's own 'truth'. Obviously with a medium to large project you may have several states. Is a specific UI window open? What tool is the player holding? What location is the player in? Rodux tackles this by creating 'The Store'. Store has a state, a reducer, and a dispatcher. The state is a simple dictionary to define the data of the store. local state = { location = \"Texas\", inventoryWindowOpen = false, weaponHeld = \"\", } Then the dispatcher handles all of the incoming action objects and sends them to the reducer. The dispatcher can be considered a middle man and a middleware can be setup to catch all actions and modify the action before being sent to the reducer. The reducer takes in an action object and the current state of the store and returns a new state based off of the action. Rodux","title":"Rodux"},{"location":"resources/#roact-rodux-integration","text":"While Roact and Rodux can be used separately for their own specific uses, they can and should be used together. Defining the current state of the user's interface prevents a lot unknown errors and simplifies the long-term development process. Roact-Rodux","title":"Roact-Rodux Integration"},{"location":"styleguide/","text":"Programming Style Guide Welcome to the Wonder Works Programming Style Guide. This is heavily inspired by Roblox Lua Style guide with a few differences. It is worth reading through that guide first then adjusting to this guide. Why Do We Have A Style Guide Working in a company means collaborating with a lot of different individuals. At Wonder Works, you will be working side by side with a lot of programmers who might join your project to assist you, give you guidance, or to take over the project themselves. In order for this to be streamlined, everyone's code needs to follow a similar structure. From readability to agreed upon best practices; everyone needs to be on the same page. Structure File Names All file names need to relate directly to the file's purpose. File Purpose Every file within your application should have a single main purpose. CurrencyService should relate only to currency. DataService should relate only to data. Source File Format Each file needs to follow this general format with very little exceptions. -- Module Documentation (briefly describe the purpose of this module) -- Service References -- Framework require -- Constant & Local variables -- CreateService / CreateController / Class Creation (Knit.CreateService / Knit.CreateController / Class.new()) -- Module code -- Return module Classes Classes should have a specific purpose and use while following this template code: local MyClass = {} MyClass.__index = MyClass function MyClass.new() local self = setmetatable({ _destroyed = false }, MyClass) return self end function MyClass:Destroy() if self._destroyed then return end self._destroyed = true end Each class needs the Destroy method so that it can be cleaned up properly by Maids. Also in general the class should most likely have its own maid that is cleaned in the Destroy method to make sure no memory leaks remain after it has served its use. Readability First and foremost - your code needs to look pleasing to the eye. If someone glances at your code they should be able to get a gist of what your intentions were and not be too overwhelmed. Variable Naming Schemes All variables should be local and should be as descriptive as needed to clearly state their purpose. Bad: local function createPart(arg1, arg2, arg3) local newPart: BasePart = Instance.new(\"Part\") newPart.Name = arg1 newPart.Size = arg2 newPart.Position = arg3 return newPart end Good: local function createPart(name: String, size: Vector3, position: Vector3) local newPart: BasePart = Instance.new(\"Part\") newPart.Name = name newPart.Size = size newPart.Position = position return newPart end Variables that retrieve services using game:GetService should be in PascalCase local RunService = game:GetService(\"RunService\") Constant variables (variables that, without a doubt, never change) that hold general information should be in UPPER_SNAKE_CASE local TREASURE_SPAWNS = 10 Otherwise, all other variables will be in camelCase local playerName = \"WonderWorksDeveloper1\" Function Naming Schemes Local functions should be written in camelCase local function createPart() end Public Methods (methods that could be accessed from a different script) should be written in PascalCase function InteractionService:HandlePrompt() end Private Methods (methods that should only be used inside this specific source file) should be written with an _underscoreCamelCase function InteractionService:_handlePrompt() end Spacing Each segment of your code needs to be spaced out accordingly. After requiring your services and framework module there should be a single space . Then another single space after requiring your other modules and delcaring any other local variables. Example: local ProximityPromptService = game:GetService(\"ProximityPromptService\") local ReplicatedStorage = game:GetService(\"ReplicatedStorage\") local Knit = require(ReplicatedStorage.Knit) local RemoteEvent = require(Knit.Util.Remote.RemoteEvent) local InteractionService = Knit.CreateService { Name = \"InteractionService\"; Client = { Triggered = RemoteEvent.new(), HoldBegan = RemoteEvent.new(), HoldEnded = RemoteEvent.new() }; } There should also be two spaces in between each function. function InteractionService:KnitStart() end -- 2 spaces function InteractionService:KnitInit() end Inside each scope you should separate each 'section' of code by a single space . Example: function InteractionService:_onPromptTriggered() local variableOne = 1 local variableTwo = 2 local variableThree = 3 if variableOne == 1 then print(\"success\") else print(\"???\") end if variableTwo >= 2 then local secondExampleVariable = true if secondExampleVariable then -- still correct spacing end end end Commenting Commenting is always a weird topic with differing opinions. What is a good comment compared to a bad comment? When are you supposed to comment and when should the code just speak for itself? Hopefully this helps lay those questions to rest. Good Comments Good comments are things you're required to do and do well. Your team is depending on you to be clear and concise, not only with your code but also with your intentions. If you have ever had someone review your code then you definitely know how two people can view the same line of code differently. As a general rule of thumb - intent comments should be included in almost every segment of code that will reduce the time it takes to understand it. Just because you know what is supposed to happen does not mean everyone will know what is supposed to happen. Example: function InteractionService:_onPromptTriggered(prompt: ProximityPrompt) -- run prompt's action if the prompt is valid if self._prompts[prompt] then if self._prompts[prompt].action then self._prompts[prompt].action() end end end This is obviously a very very small example. This should be taken more seriously when you have a several lines of code after the initial if statement and a developer might have to take several minutes to even grasp what is going on. Comments that document the overall purpose of this file. Although the file name should already do that job, it helps to add in more context that is precise and to the point. Example: --[[ PartService will create different types of parts that hold special properties. ]] local ReplicatedStorage = game:GetService(\"ReplicatedStorage\") local Knit = require(ReplicatedStorage.Knit) Bad Comments Comments that add more lines without adding more understanding to the current code. Example: local function createPart() -- I would like to move this to PartService soon maybe? local newPart = Instance.new(\"Part\") return newPart end Long Comments that defeat the purpose of a \" quicker and better understanding\" Example: local function createPart(arg1, arg2, arg3) --[[ So createPart takes in 3 arguments, name, size, and position. Name refers to what I'll name the part Size refers to the size of the part (how big it is!) Position refers to where the part will be in the world Then this function will create a new part, set those 3 properties, and return the new part! Afterwards you can modify the part as you see fit and delete it after it has been used ]] end Restating code. You should never state what your code is already specifically saying; only its intent. Bad example: local function createPart(name, size, position) -- create part with Instance.new() then set its properties local newPart = Instance.new(\"Part\") newPart.Name = name newPart.Size = size newPart.Position = position return newPart end Type Checking While tedious, type checking is greatly preferred everywhere BUT only required on your function arguments. function InteractionService:_onPromptTriggered(prompt: ProximityPrompt) local variableOne: number = 1 local variableTwo: number = 2 local variableThree: number = 3 end You don't have to add the --!strict tag at the beginning of each script though unless you want to ensure you're not making any mistakes. This is just for readability purposes. Yes, I may see that variableOne is 1 but when the code can be potentially hundreds of lines it is hard to just tell what this argument is used for and why. Defining the type helps with any possible confusion. For more guidance and assistance check this link.","title":"Style Guide"},{"location":"styleguide/#programming-style-guide","text":"Welcome to the Wonder Works Programming Style Guide. This is heavily inspired by Roblox Lua Style guide with a few differences. It is worth reading through that guide first then adjusting to this guide.","title":"Programming Style Guide"},{"location":"styleguide/#why-do-we-have-a-style-guide","text":"Working in a company means collaborating with a lot of different individuals. At Wonder Works, you will be working side by side with a lot of programmers who might join your project to assist you, give you guidance, or to take over the project themselves. In order for this to be streamlined, everyone's code needs to follow a similar structure. From readability to agreed upon best practices; everyone needs to be on the same page.","title":"Why Do We Have A Style Guide"},{"location":"styleguide/#structure","text":"","title":"Structure"},{"location":"styleguide/#file-names","text":"All file names need to relate directly to the file's purpose.","title":"File Names"},{"location":"styleguide/#file-purpose","text":"Every file within your application should have a single main purpose. CurrencyService should relate only to currency. DataService should relate only to data.","title":"File Purpose"},{"location":"styleguide/#source-file-format","text":"Each file needs to follow this general format with very little exceptions. -- Module Documentation (briefly describe the purpose of this module) -- Service References -- Framework require -- Constant & Local variables -- CreateService / CreateController / Class Creation (Knit.CreateService / Knit.CreateController / Class.new()) -- Module code -- Return module","title":"Source File Format"},{"location":"styleguide/#classes","text":"Classes should have a specific purpose and use while following this template code: local MyClass = {} MyClass.__index = MyClass function MyClass.new() local self = setmetatable({ _destroyed = false }, MyClass) return self end function MyClass:Destroy() if self._destroyed then return end self._destroyed = true end Each class needs the Destroy method so that it can be cleaned up properly by Maids. Also in general the class should most likely have its own maid that is cleaned in the Destroy method to make sure no memory leaks remain after it has served its use.","title":"Classes"},{"location":"styleguide/#readability","text":"First and foremost - your code needs to look pleasing to the eye. If someone glances at your code they should be able to get a gist of what your intentions were and not be too overwhelmed.","title":"Readability"},{"location":"styleguide/#variable-naming-schemes","text":"All variables should be local and should be as descriptive as needed to clearly state their purpose. Bad: local function createPart(arg1, arg2, arg3) local newPart: BasePart = Instance.new(\"Part\") newPart.Name = arg1 newPart.Size = arg2 newPart.Position = arg3 return newPart end Good: local function createPart(name: String, size: Vector3, position: Vector3) local newPart: BasePart = Instance.new(\"Part\") newPart.Name = name newPart.Size = size newPart.Position = position return newPart end Variables that retrieve services using game:GetService should be in PascalCase local RunService = game:GetService(\"RunService\") Constant variables (variables that, without a doubt, never change) that hold general information should be in UPPER_SNAKE_CASE local TREASURE_SPAWNS = 10 Otherwise, all other variables will be in camelCase local playerName = \"WonderWorksDeveloper1\"","title":"Variable Naming Schemes"},{"location":"styleguide/#function-naming-schemes","text":"Local functions should be written in camelCase local function createPart() end Public Methods (methods that could be accessed from a different script) should be written in PascalCase function InteractionService:HandlePrompt() end Private Methods (methods that should only be used inside this specific source file) should be written with an _underscoreCamelCase function InteractionService:_handlePrompt() end","title":"Function Naming Schemes"},{"location":"styleguide/#spacing","text":"Each segment of your code needs to be spaced out accordingly. After requiring your services and framework module there should be a single space . Then another single space after requiring your other modules and delcaring any other local variables. Example: local ProximityPromptService = game:GetService(\"ProximityPromptService\") local ReplicatedStorage = game:GetService(\"ReplicatedStorage\") local Knit = require(ReplicatedStorage.Knit) local RemoteEvent = require(Knit.Util.Remote.RemoteEvent) local InteractionService = Knit.CreateService { Name = \"InteractionService\"; Client = { Triggered = RemoteEvent.new(), HoldBegan = RemoteEvent.new(), HoldEnded = RemoteEvent.new() }; } There should also be two spaces in between each function. function InteractionService:KnitStart() end -- 2 spaces function InteractionService:KnitInit() end Inside each scope you should separate each 'section' of code by a single space . Example: function InteractionService:_onPromptTriggered() local variableOne = 1 local variableTwo = 2 local variableThree = 3 if variableOne == 1 then print(\"success\") else print(\"???\") end if variableTwo >= 2 then local secondExampleVariable = true if secondExampleVariable then -- still correct spacing end end end","title":"Spacing"},{"location":"styleguide/#commenting","text":"Commenting is always a weird topic with differing opinions. What is a good comment compared to a bad comment? When are you supposed to comment and when should the code just speak for itself? Hopefully this helps lay those questions to rest.","title":"Commenting"},{"location":"styleguide/#good-comments","text":"Good comments are things you're required to do and do well. Your team is depending on you to be clear and concise, not only with your code but also with your intentions. If you have ever had someone review your code then you definitely know how two people can view the same line of code differently. As a general rule of thumb - intent comments should be included in almost every segment of code that will reduce the time it takes to understand it. Just because you know what is supposed to happen does not mean everyone will know what is supposed to happen. Example: function InteractionService:_onPromptTriggered(prompt: ProximityPrompt) -- run prompt's action if the prompt is valid if self._prompts[prompt] then if self._prompts[prompt].action then self._prompts[prompt].action() end end end This is obviously a very very small example. This should be taken more seriously when you have a several lines of code after the initial if statement and a developer might have to take several minutes to even grasp what is going on. Comments that document the overall purpose of this file. Although the file name should already do that job, it helps to add in more context that is precise and to the point. Example: --[[ PartService will create different types of parts that hold special properties. ]] local ReplicatedStorage = game:GetService(\"ReplicatedStorage\") local Knit = require(ReplicatedStorage.Knit)","title":"Good Comments"},{"location":"styleguide/#bad-comments","text":"Comments that add more lines without adding more understanding to the current code. Example: local function createPart() -- I would like to move this to PartService soon maybe? local newPart = Instance.new(\"Part\") return newPart end Long Comments that defeat the purpose of a \" quicker and better understanding\" Example: local function createPart(arg1, arg2, arg3) --[[ So createPart takes in 3 arguments, name, size, and position. Name refers to what I'll name the part Size refers to the size of the part (how big it is!) Position refers to where the part will be in the world Then this function will create a new part, set those 3 properties, and return the new part! Afterwards you can modify the part as you see fit and delete it after it has been used ]] end Restating code. You should never state what your code is already specifically saying; only its intent. Bad example: local function createPart(name, size, position) -- create part with Instance.new() then set its properties local newPart = Instance.new(\"Part\") newPart.Name = name newPart.Size = size newPart.Position = position return newPart end","title":"Bad Comments"},{"location":"styleguide/#type-checking","text":"While tedious, type checking is greatly preferred everywhere BUT only required on your function arguments. function InteractionService:_onPromptTriggered(prompt: ProximityPrompt) local variableOne: number = 1 local variableTwo: number = 2 local variableThree: number = 3 end You don't have to add the --!strict tag at the beginning of each script though unless you want to ensure you're not making any mistakes. This is just for readability purposes. Yes, I may see that variableOne is 1 but when the code can be potentially hundreds of lines it is hard to just tell what this argument is used for and why. Defining the type helps with any possible confusion. For more guidance and assistance check this link.","title":"Type Checking"}]}